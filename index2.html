<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Isometric Grid Generator</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }
    
    canvas {
      display: block;
    }
    
    #control-panel {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background-color: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 15px 20px;
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      align-items: center;
    }
    
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    
    .control-label {
      font-size: 11px;
      opacity: 0.8;
    }
    
    .slider-container {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    input[type="range"] {
      width: 120px;
    }
    
    .value-display {
      font-size: 12px;
      font-weight: bold;
      min-width: 30px;
    }
    
    button {
      background-color: #4CAF50;
      color: white;
      border: none;
      padding: 10px 20px;
      cursor: pointer;
      border-radius: 4px;
      font-size: 12px;
    }
    
    button:hover {
      background-color: #45a049;
    }
    
    select {
      background-color: #333;
      color: white;
      border: 1px solid #555;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 12px;
      cursor: pointer;
    }
    
    select:hover {
      background-color: #444;
    }
    
    .button-group {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-left: auto;
    }
    
    input[type="color"] {
      width: 40px;
      height: 30px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    
    .color-control {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    
    .section-divider {
      width: 2px;
      height: 40px;
      background-color: rgba(255, 255, 255, 0.2);
      margin: 0 10px;
    }
    
    .settings-section {
      display: flex;
      gap: 15px;
      align-items: center;
      padding: 5px 10px;
      border-radius: 4px;
      background-color: rgba(255, 255, 255, 0.05);
    }
    
    .swatch-container {
      display: flex;
      gap: 5px;
      align-items: center;
      flex-wrap: wrap;
    }
    
    .color-swatch {
      width: 30px;
      height: 30px;
      border-radius: 4px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      cursor: pointer;
      position: relative;
      overflow: hidden;
    }
    
    .color-swatch input[type="color"] {
      position: absolute;
      width: 100%;
      height: 100%;
      opacity: 0;
      cursor: pointer;
      border: none;
      padding: 0;
      margin: 0;
    }
    
    .color-swatch:hover {
      border-color: rgba(255, 255, 255, 0.6);
    }
    
    .swatch-remove {
      position: absolute;
      top: -8px;
      right: -8px;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background-color: #ff4444;
      color: white;
      border: none;
      font-size: 12px;
      line-height: 18px;
      cursor: pointer;
      display: none;
      padding: 0;
    }
    
    .color-swatch:hover .swatch-remove {
      display: block;
    }
    
    .add-swatch {
      width: 30px;
      height: 30px;
      border-radius: 4px;
      border: 2px dashed rgba(255, 255, 255, 0.3);
      background-color: transparent;
      color: white;
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
    }
    
    .add-swatch:hover {
      border-color: rgba(255, 255, 255, 0.6);
      background-color: rgba(255, 255, 255, 0.1);
    }
    
    .color-picker-popup {
      position: absolute;
      z-index: 1000;
      display: none;
    }
  </style>
</head>
<body>
  <script>
    let gridSize = 30;
    let dotSize = 3;
    let bgColor, dotColor;
    let triangles = [];
    let generationModel = 'random';
    let strokeColor;
    let strokeWidth = 0;
    let strokeJoinMode = 'miter';
    let fillColors = []; // Array of fill colors
    let currentPalette = [];
    let paletteMode = 'builtin';
    
    // Built-in color palettes
    const builtInPalettes = [
      [[255, 99, 71], [255, 165, 0], [255, 215, 0], [144, 238, 144], [100, 149, 237]],
      [[230, 57, 70], [241, 250, 238], [168, 218, 220], [69, 123, 157], [29, 53, 87]],
      [[242, 233, 228], [221, 184, 146], [188, 108, 37], [139, 69, 19], [74, 40, 14]],
      [[255, 190, 11], [251, 86, 7], [255, 0, 110], [131, 56, 236], [58, 134, 255]],
      [[26, 28, 44], [93, 39, 93], [177, 62, 83], [239, 125, 87], [255, 205, 117]],
      [[2, 48, 71], [33, 158, 188], [142, 202, 230], [255, 183, 3], [251, 133, 0]],
      [[106, 13, 173], [149, 46, 191], [186, 73, 213], [224, 130, 237], [255, 193, 253]]
    ];
    
    function setup() {
      createCanvas(windowWidth, windowHeight);
      bgColor = color(255, 255, 255);
      dotColor = color(200, 200, 200);
      strokeColor = color(0, 0, 0);
      fillColors = [color(50, 50, 50)];
      
      // Initialize stroke join mode
      strokeJoinMode = MITER;
      
      // Initialize with a random built-in palette
      currentPalette = random(builtInPalettes);
      
      createControls();
    }
    
    function draw() {
      background(bgColor);
      drawFilledTriangles();
      drawIsometricTriangleGrid();
    }
    
    function drawIsometricTriangleGrid() {
      noStroke();
      fill(dotColor);
      
      const triangleHeight = (Math.sqrt(3) / 2) * gridSize;
      const halfSize = gridSize / 2;
      const numRows = Math.ceil(height / triangleHeight) + 2;
      const numCols = Math.ceil(width / gridSize) + 2;
      const startX = -gridSize;
      const startY = -triangleHeight;
      
      for (let row = 0; row < numRows; row++) {
        for (let col = 0; col < numCols; col++) {
          let x, y;
          
          if (row % 2 === 0) {
            x = startX + col * gridSize;
            y = startY + row * triangleHeight;
          } else {
            x = startX + col * gridSize + halfSize;
            y = startY + row * triangleHeight;
          }
          
          circle(x, y, dotSize);
        }
      }
    }
    
    function drawFilledTriangles() {
      const triangleHeight = (Math.sqrt(3) / 2) * gridSize;
      const halfSize = gridSize / 2;
      const startX = -gridSize;
      const startY = -triangleHeight;
      
      if (strokeWidth > 0) {
        stroke(strokeColor);
        strokeWeight(strokeWidth);
        strokeJoin(strokeJoinMode);
      } else {
        noStroke();
      }
      
      const getGridPoint = (r, c) => {
        if (r % 2 === 0) {
          return {x: startX + c * gridSize, y: startY + r * triangleHeight};
        } else {
          return {x: startX + c * gridSize + halfSize, y: startY + r * triangleHeight};
        }
      };
      
      for (let tri of triangles) {
        // Use color index to pick from current fillColors array
        if (tri.colorIndex !== undefined && fillColors.length > 0) {
          let idx = tri.colorIndex % fillColors.length;
          fill(fillColors[idx]);
        } else {
          fill(fillColors[0] || color(50, 50, 50));
        }
        
        let v1, v2, v3;
        
        if (tri.pointsUp) {
          v1 = getGridPoint(tri.row, tri.col);
          v2 = getGridPoint(tri.row, tri.col + 1);
          
          if (tri.row % 2 === 0) {
            v3 = getGridPoint(tri.row + 1, tri.col);
          } else {
            v3 = getGridPoint(tri.row + 1, tri.col + 1);
          }
        } else {
          if (tri.row % 2 === 0) {
            v1 = getGridPoint(tri.row, tri.col + 1);
            v2 = getGridPoint(tri.row + 1, tri.col);
            v3 = getGridPoint(tri.row + 1, tri.col + 1);
          } else {
            v1 = getGridPoint(tri.row, tri.col);
            v2 = getGridPoint(tri.row + 1, tri.col);
            v3 = getGridPoint(tri.row + 1, tri.col + 1);
          }
        }
        
        beginShape();
        vertex(v1.x, v1.y);
        vertex(v2.x, v2.y);
        vertex(v3.x, v3.y);
        endShape(CLOSE);
      }
    }
    
    function getTriangleColor() {
      // Return a random index into fillColors array
      if (fillColors.length === 0) return 0;
      return floor(random(fillColors.length));
    }
    
    function generateRandomTriangles() {
      triangles = [];
      
      const triangleHeight = (Math.sqrt(3) / 2) * gridSize;
      const numRows = Math.ceil(height / triangleHeight) + 2;
      const numCols = Math.ceil(width / gridSize) + 2;
      
      let density;
      
      switch(generationModel) {
        case 'random':
          density = 0.15;
          for (let row = 0; row < numRows; row++) {
            for (let col = 0; col < numCols; col++) {
              if (random() < density) {
                triangles.push({row, col, pointsUp: true, colorIndex: getTriangleColor()});
              }
              if (random() < density) {
                triangles.push({row, col, pointsUp: false, colorIndex: getTriangleColor()});
              }
            }
          }
          break;
          
        case 'sparse':
          density = 0.05;
          for (let row = 0; row < numRows; row++) {
            for (let col = 0; col < numCols; col++) {
              if (random() < density) {
                triangles.push({row, col, pointsUp: random() > 0.5, colorIndex: getTriangleColor()});
              }
            }
          }
          break;
          
        case 'dense':
          density = 0.3;
          for (let row = 0; row < numRows; row++) {
            for (let col = 0; col < numCols; col++) {
              if (random() < density) {
                triangles.push({row, col, pointsUp: true, colorIndex: getTriangleColor()});
              }
              if (random() < density) {
                triangles.push({row, col, pointsUp: false, colorIndex: getTriangleColor()});
              }
            }
          }
          break;
          
        case 'clustered':
          let seeds = [];
          for (let i = 0; i < 10; i++) {
            seeds.push({
              row: floor(random(numRows)),
              col: floor(random(numCols))
            });
          }
          
          for (let seed of seeds) {
            let clusterSize = floor(random(5, 15));
            for (let i = 0; i < clusterSize; i++) {
              let row = seed.row + floor(random(-3, 4));
              let col = seed.col + floor(random(-3, 4));
              if (row >= 0 && row < numRows && col >= 0 && col < numCols) {
                if (random() > 0.5) {
                  triangles.push({row, col, pointsUp: random() > 0.5, colorIndex: getTriangleColor()});
                }
              }
            }
          }
          break;
          
        case 'diagonal':
          for (let row = 0; row < numRows; row++) {
            for (let col = 0; col < numCols; col++) {
              if ((row + col) % 5 < 2 && random() > 0.3) {
                triangles.push({row, col, pointsUp: (row + col) % 2 === 0, colorIndex: getTriangleColor()});
              }
            }
          }
          break;
          
        case 'connected':
          let numSnakes = floor(random(5, 12));
          let used = new Set();
          
          for (let s = 0; s < numSnakes; s++) {
            let snakeLength = floor(random(6, 13));
            let startRow = floor(random(numRows));
            let startCol = floor(random(numCols));
            let startUp = random() > 0.5;
            
            let currentTri = {row: startRow, col: startCol, pointsUp: startUp};
            let snake = [];
            
            for (let i = 0; i < snakeLength; i++) {
              let key = `${currentTri.row},${currentTri.col},${currentTri.pointsUp}`;
              
              if (used.has(key)) break;
              
              snake.push({...currentTri, colorIndex: getTriangleColor()});
              used.add(key);
              
              let neighbors = getAdjacentTriangles(currentTri.row, currentTri.col, currentTri.pointsUp, numRows, numCols);
              
              neighbors = neighbors.filter(n => {
                let nKey = `${n.row},${n.col},${n.pointsUp}`;
                return !used.has(nKey);
              });
              
              if (neighbors.length === 0) break;
              
              currentTri = neighbors[floor(random(neighbors.length))];
            }
            
            triangles.push(...snake);
          }
          break;
      }
    }
    
    function getAdjacentTriangles(row, col, pointsUp, maxRows, maxCols) {
      let adjacent = [];
      
      if (pointsUp) {
        if (row % 2 === 0) {
          if (col > 0) {
            adjacent.push({row, col: col - 1, pointsUp: false});
          }
          adjacent.push({row, col, pointsUp: false});
          if (row + 1 < maxRows) {
            adjacent.push({row: row + 1, col, pointsUp: false});
          }
        } else {
          adjacent.push({row, col, pointsUp: false});
          if (col + 1 < maxCols) {
            adjacent.push({row, col: col + 1, pointsUp: false});
          }
          if (row + 1 < maxRows) {
            adjacent.push({row: row + 1, col, pointsUp: false});
          }
        }
      } else {
        if (row % 2 === 0) {
          if (row > 0) {
            adjacent.push({row: row - 1, col, pointsUp: true});
          }
          adjacent.push({row, col, pointsUp: true});
          if (col + 1 < maxCols) {
            adjacent.push({row, col: col + 1, pointsUp: true});
          }
        } else {
          if (row > 0) {
            adjacent.push({row: row - 1, col, pointsUp: true});
          }
          if (col > 0) {
            adjacent.push({row, col: col - 1, pointsUp: true});
          }
          adjacent.push({row, col, pointsUp: true});
        }
      }
      
      return adjacent;
    }
    
    function createControls() {
      // Add event listeners for HTML sliders
      document.getElementById('size-slider').addEventListener('input', (e) => {
        gridSize = parseFloat(e.target.value);
        document.getElementById('size-value').textContent = gridSize;
      });
      
      document.getElementById('dot-slider').addEventListener('input', (e) => {
        dotSize = parseFloat(e.target.value);
        document.getElementById('dot-value').textContent = dotSize.toFixed(1);
      });
      
      document.getElementById('stroke-slider').addEventListener('input', (e) => {
        strokeWidth = parseFloat(e.target.value);
        document.getElementById('stroke-width-value').textContent = strokeWidth.toFixed(1);
      });
    }
    
    function loadSwatches() {
      if (paletteMode === 'builtin') {
        currentPalette = random(builtInPalettes);
      } else {
        // Fetch from Colormind API
        fetch('http://colormind.io/api/', {
          method: 'POST',
          body: JSON.stringify({model: 'default'})
        })
        .then(response => response.json())
        .then(data => {
          currentPalette = data.result;
          applyPaletteToSwatches();
        })
        .catch(err => {
          console.error('Failed to load palette, using built-in', err);
          currentPalette = random(builtInPalettes);
          applyPaletteToSwatches();
        });
        return;
      }
      
      applyPaletteToSwatches();
    }
    
    function applyPaletteToSwatches() {
      if (currentPalette.length === 0) return;
      
      // Set background to first color
      let bgC = currentPalette[0];
      bgColor = color(bgC[0], bgC[1], bgC[2]);
      updateSwatchDisplay('bg-swatch', bgColor);
      const bgInput = document.querySelector('#bg-swatch input[type="color"]');
      if (bgInput) {
        const r = bgC[0].toString(16).padStart(2, '0');
        const g = bgC[1].toString(16).padStart(2, '0');
        const b = bgC[2].toString(16).padStart(2, '0');
        bgInput.value = '#' + r + g + b;
      }
      
      // Set stroke to second color
      if (currentPalette.length > 1) {
        let strokeC = currentPalette[1];
        strokeColor = color(strokeC[0], strokeC[1], strokeC[2]);
        updateSwatchDisplay('stroke-swatch', strokeColor);
        const strokeInput = document.querySelector('#stroke-swatch input[type="color"]');
        if (strokeInput) {
          const r = strokeC[0].toString(16).padStart(2, '0');
          const g = strokeC[1].toString(16).padStart(2, '0');
          const b = strokeC[2].toString(16).padStart(2, '0');
          strokeInput.value = '#' + r + g + b;
        }
      }
      
      // Set fill colors to remaining colors
      fillColors = [];
      for (let i = 2; i < currentPalette.length; i++) {
        let c = currentPalette[i];
        fillColors.push(color(c[0], c[1], c[2]));
      }
      
      // Update fill swatches display
      rebuildFillSwatches();
    }
    
    function rebuildFillSwatches() {
      const container = document.getElementById('fill-swatches');
      container.innerHTML = '';
      
      fillColors.forEach((c, i) => {
        const swatch = document.createElement('div');
        swatch.className = 'color-swatch';
        swatch.style.backgroundColor = `rgb(${red(c)}, ${green(c)}, ${blue(c)})`;
        
        // Add color input
        const colorInput = document.createElement('input');
        colorInput.type = 'color';
        const r = Math.round(red(c)).toString(16).padStart(2, '0');
        const g = Math.round(green(c)).toString(16).padStart(2, '0');
        const b = Math.round(blue(c)).toString(16).padStart(2, '0');
        colorInput.value = '#' + r + g + b;
        colorInput.onchange = (e) => updateSwatchColor('fill', i, e.target.value);
        swatch.appendChild(colorInput);
        
        const removeBtn = document.createElement('button');
        removeBtn.className = 'swatch-remove';
        removeBtn.textContent = '×';
        removeBtn.onclick = (e) => {
          e.stopPropagation();
          removeFillSwatch(i);
        };
        
        swatch.appendChild(removeBtn);
        container.appendChild(swatch);
      });
      
      // Add the + button
      const addBtn = document.createElement('button');
      addBtn.className = 'add-swatch';
      addBtn.textContent = '+';
      addBtn.onclick = addFillSwatch;
      container.appendChild(addBtn);
    }
    
    function addFillSwatch() {
      // Add a random color from palette or a default color
      if (currentPalette.length > 0) {
        let c = random(currentPalette);
        fillColors.push(color(c[0], c[1], c[2]));
      } else {
        fillColors.push(color(random(255), random(255), random(255)));
      }
      rebuildFillSwatches();
    }
    
    function removeFillSwatch(index) {
      if (fillColors.length > 1) {
        fillColors.splice(index, 1);
        rebuildFillSwatches();
      }
    }
    
    function updateSwatchColor(type, index, hex) {
      const r = parseInt(hex.substr(1, 2), 16);
      const g = parseInt(hex.substr(3, 2), 16);
      const b = parseInt(hex.substr(5, 2), 16);
      const newColor = color(r, g, b);
      
      if (type === 'background') {
        bgColor = newColor;
        updateSwatchDisplay('bg-swatch', bgColor);
      } else if (type === 'stroke') {
        strokeColor = newColor;
        updateSwatchDisplay('stroke-swatch', strokeColor);
      } else if (type === 'fill') {
        fillColors[index] = newColor;
        // Update just the background color of the parent swatch
        const swatches = document.getElementById('fill-swatches').querySelectorAll('.color-swatch');
        if (swatches[index]) {
          swatches[index].style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
        }
      }
    }
    
    function updateSwatchDisplay(id, c) {
      const swatch = document.getElementById(id);
      if (swatch) {
        swatch.style.backgroundColor = `rgb(${red(c)}, ${green(c)}, ${blue(c)})`;
      }
    }
    
    function updatePaletteMode(mode) {
      paletteMode = mode;
    }
    
    function updateStrokeJoin(mode) {
      if (mode === 'round') {
        strokeJoinMode = ROUND;
      } else if (mode === 'bevel') {
        strokeJoinMode = BEVEL;
      } else {
        strokeJoinMode = MITER;
      }
    }
    
    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
    }
    
    function saveImage() {
      save('isometric-grid.png');
    }
  </script>
  
  <div id="control-panel">
    <!-- Grid Settings -->
    <div class="settings-section">
      <div class="control-group">
        <span class="control-label">Triangle Size</span>
        <div class="slider-container">
          <div id="size-value" class="value-display">30</div>
          <input type="range" id="size-slider" min="10" max="80" value="30" step="1">
        </div>
      </div>
      
      <div class="control-group">
        <span class="control-label">Dot Size</span>
        <div class="slider-container">
          <div id="dot-value" class="value-display">3.0</div>
          <input type="range" id="dot-slider" min="0" max="10" value="3" step="0.5">
        </div>
      </div>
    </div>
    
    <div class="section-divider"></div>
    
    <!-- Palette/Swatch Settings -->
    <div class="settings-section">
      <div class="control-group">
        <span class="control-label">Swatch Source</span>
        <select id="palette-source" onchange="updatePaletteMode(this.value)">
          <option value="builtin">Built-in</option>
          <option value="api">Colormind API</option>
        </select>
      </div>
      
      <div class="control-group">
        <button onclick="loadSwatches()">Load Swatches</button>
      </div>
    </div>
    
    <div class="section-divider"></div>
    
    <!-- Color Swatches -->
    <div class="settings-section">
      <div class="control-group">
        <span class="control-label">Background:</span>
        <div class="swatch-container">
          <div class="color-swatch" id="bg-swatch" style="background-color: rgb(255, 255, 255);">
            <input type="color" value="#ffffff" onchange="updateSwatchColor('background', 0, this.value)">
          </div>
        </div>
      </div>
      
      <div class="control-group">
        <span class="control-label">Stroke:</span>
        <div class="swatch-container">
          <div class="color-swatch" id="stroke-swatch" style="background-color: rgb(0, 0, 0);">
            <input type="color" value="#000000" onchange="updateSwatchColor('stroke', 0, this.value)">
          </div>
        </div>
      </div>
      
      <div class="control-group">
        <span class="control-label">Fill:</span>
        <div class="swatch-container" id="fill-swatches">
          <div class="color-swatch" style="background-color: rgb(50, 50, 50);">
            <input type="color" value="#323232" onchange="updateSwatchColor('fill', 0, this.value)">
            <button class="swatch-remove" onclick="event.stopPropagation(); removeFillSwatch(0)">×</button>
          </div>
          <button class="add-swatch" onclick="addFillSwatch()">+</button>
        </div>
      </div>
    </div>
    
    <div class="section-divider"></div>
    
    <!-- Stroke Settings -->
    <div class="settings-section">
      <div class="control-group">
        <span class="control-label">Stroke Width</span>
        <div class="slider-container">
          <div id="stroke-width-value" class="value-display">0.0</div>
          <input type="range" id="stroke-slider" min="0" max="10" value="0" step="0.5">
        </div>
      </div>
      
      <div class="control-group">
        <span class="control-label">Stroke Corners</span>
        <select id="stroke-join" onchange="updateStrokeJoin(this.value)">
          <option value="miter">Sharp</option>
          <option value="round">Rounded</option>
          <option value="bevel">Beveled</option>
        </select>
      </div>
    </div>
    
    <div class="section-divider"></div>
    
    <!-- Generation Settings -->
    <div class="button-group">
      <select id="model-select" onchange="generationModel = this.value">
        <option value="random">Random</option>
        <option value="sparse">Sparse</option>
        <option value="dense">Dense</option>
        <option value="clustered">Clustered</option>
        <option value="diagonal">Diagonal</option>
        <option value="connected">Connected Snakes</option>
      </select>
      <button onclick="generateRandomTriangles()">Generate Random Tris</button>
      <button onclick="triangles = []">Clear</button>
      <button onclick="saveImage()">Save PNG</button>
    </div>
  </div>
  
  <script>
    function mountSliders() {
      if (window.sizeSlider) {
        document.getElementById('size-slider').appendChild(window.sizeSlider.elt);
      }
      if (window.dotSlider) {
        document.getElementById('dot-slider').appendChild(window.dotSlider.elt);
      }
      if (window.strokeSlider) {
        document.getElementById('stroke-slider').appendChild(window.strokeSlider.elt);
      }
      if (window.satSlider) {
        document.getElementById('saturation-slider').appendChild(window.satSlider.elt);
      }
      if (window.brightSlider) {
    // Setup is called after DOM is ready, so sliders should work